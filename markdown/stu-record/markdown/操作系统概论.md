# 操作系统概论

## 操作系统简介



### 什么是操作系统

- 操作系统是覆盖在裸机上的`第一层`软件，编译程序、数据库管理系统及其他应用程序都运行在操作系统之上，操作系统为这些软件提供运行环境。
- 在计算机专业领域，接口分为`硬件接口`和`软件接口`，硬件接口如USB接口、串口和并口，软件接口如C语言中的函数`prinft()`。

> 操作系统必须完成的两个目标
>
> 1. 与硬件部分相互作用，为包含在硬件平台上的所有底层可编程部件提供服务。
> 2. 为运行在计算机系统上的应用程序（即所谓用户程序）提供执行环境。

- 现代计算机系统的一个重要特点就是`支持多任务`，既允许在同一个系统内同时驻留多个应用程序
- 操作系统所管理的资源主要包括`处理机`、`内存`、`设备`和`文件`，在网络操作系统中还包括`网卡`、`宽带`等

> 操作系统的主要功能
>
> 1. 处理机管理。在单处理机系统中执行多个程序流，必须由操作系统的处理机调度程序来管理处理机的分配，以使多个程序共享处理机，从宏观上看多个程序能同时顺利执行。在多处理机系统中，也需要操作系统对多个处理机在多任务的情况下进行有效的管理。
> 2. 内存管理。在多任务系统中，内存不再是独占资源，而是可能被多个应用程序共同占用。如何为多个应用程序分配内存并使不同程序的地址空间互不干扰，如何在程序执行完毕之后回收其所占内存，以及完成逻辑地址到物理地址的转换，都是操作系统内存管理程序要完成的功能。
> 3. 设备管理。设备管理主要完成接受用户的I/O请求，为用户分配I/O设备、管理I/O缓存和驱动I/O设备等功能。
> 4. 文件管理。计算机系统把大量需要长时间保留的数据信息以文件的形式存放在外存储设备中（如硬盘、光盘、磁带和U盘），操作系统通过自己的文件管理程序完成外空间的分配、回收、文件的按名存取、文件的组织、共享与保护等功能。



### 操作系统的发展

- 操作系统的发展从时间顺序上经历了从`无操作系统系列`到`单道批处理系统`、`多道程序系统`（多道批处理系统、分时系统）的发展过程。随着计算机应用领域的扩大，计算机体系结构的多样化，有出现了`微机操作系统`、`网络操作系统`、`实时操作系统`、`嵌入式操作系统`和`物联网操作系统`。
- 第一代计算机（1945~1955）使用`电子管`作为主要电子器件，用插件版上的硬件连线或穿孔卡片表示程序，没有用来存储的内存，无操作系统。
- 第二代计算机（1955~1965）使用的主要电子器件是`晶体管`，开始使用`磁性存储设备`，内存容量增加，计算机运算速度提高，出现了早起的单道批处理系统。
- 操作员在专门用于计算的、性能较高的计算机上装入早期的操作系统，也称`监视系统`，它能自动从磁带读入作业并使之运行，把作业运行结果写入专门存放输出结果的磁带上。
- 随着电子技术的发展，计算机采用集成`电路芯片`作为主要的电子器件，IBM360使第一个采用小规模集成电路芯片的主流机型。
- `实时系统`是支持实时计算的系统。

> 批处理系统、分时系统、实时系统的特点
>
> 1. 单道批处理系统的特点。单道批处理系统内存中只有一道作业，可以自动成批处理作业，其特点包括自动性、顺序性、单道性。
> 2. 多道批处理系统的特点。在多道批处理系统中，用户所提交的作业都先存放在外存中并排列成一个队列，该队列被称为“后备作业队列”。与单道批处理系统相比，多道批处理系统支持多道程序驻留内存，CPU可以不再空闲等待I/O。多道批处理系统的特点包括多道性、无序性、调度性、复杂性。多道批处理系统的优点是能提高CPU、内存和I/O设备的利用率和系统的吞吐量。多道批处理系统的缺点是系统平均周转时间长，缺乏交互能力。周转时间是指从作业被提交给系统开始到作业完成为止的时间。
> 3. 分时系统的特点。分时操作系统允许多个用户通过终端同时使用计算机，分时系统的特点包括多路性、独立性、及时性和交互性。分时系统的优点是向用户特供了人机交互的方便性，使多个用户可以通过不同的终端共享主机。
> 4. 实时系统的特点。实时系统主要用于实时控制和实时信息处理领域。实时系统必须能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。与分时系统相比，实时系统的特点包括多路性、独立性、及时性、交互性、可靠性。

- 分时系统的实现需要解决两个关键问题，即`及时接收`和`及时处理`。
- 主机操作系统是运行在大型主机上的操作系统，主要提供三类服务：`批处理`、`事务处理`和`分时处理`。
- 批处理系统处理不需要交互式用户干预的周期作业，`保险公司的索赔处理`或者`连锁商店的销售报告`通常以批处理的方式完成。
- `事务处理系统`负责大量的小请求。
- `分时系统`允许多个远程用户同时在计算机上工作，执行命令或处理作业。
- `嵌入式系统`的概念出现在20世纪70年代，是宿主于非计算机设备中的计算机系统。嵌入式操作系统是运用于嵌入式设备中的操作系统。



### 操作系统的特征

- 现代操作系统都支持多任务，具有`并发`、`共享`、`虚拟`和`异步`特征。



### 操作系统的功能

- 内存管理的主要任务是`为多道程序的运行提供良好的环境`，方便用户使用内存，提高内存的利用率，以及从逻辑上扩充内存以实现虚拟存储。
- 内存管理应具有`内存分配`、`内存保护`、`地址映射`和`内存扩充`功能。

> 内存保护的任务
>
> 1. 使操作系统内核空间不会被用户随意访问，以保证系统的安全和稳定。
> 2. 确保每道用户程序都在自己的空间中运行，互不干扰。

- CPU执行程序过程中访问内存时，需要把程序的逻辑地址转变为物理地址，这个转换的过程称为`地址映射`。
- 为了能从逻辑上扩充内存，系统必须具有内存扩充机制，以实现`请求调入功能`和`置换功能`。
- 进程管理功能主要包括`进程的描述与组织`、`进程控制`、`进程同步`、`进程通信`及`进程调度`。

> 设备管理应该具有的功能
>
> 1. 缓冲管理。管理各种缓冲区。
> 2. 设备分配。分配用户I/O所需要的设备。
> 3. 设备处理。由设备驱动程序来实现CPU与设备控制器之间的通信。
> 4. 设备独立性和虚拟设备。设备独立性功能使应用程序独立于物理设备。

- 目录包括`文件名`、`文件属性`及`文件的地址`等信息。
- 操作系统提供给程序员的接口是`系统调用`。



### 操作系统的体系结构

- `明确清晰的软件体系结构`是一种贯穿软件系统整个生命周期的主线，是软件设计成功的基础和关键，也是对软件大型化、复杂化趋势的一种很好的应对决策。
- `单体内核`是操作系统中最早、最常见的体系结构。
- 具有单体内核结构的典型操作系统有`UNIX系统`、`MS-DOS`、`Linux`、`Mac OS X`和`BSD`等系统。

> 层次结构的基本思想
>
> 将操作系统分解为多个小的、容易理解的层，系统功能被隔离在不同的层中，每一层提供对系统功能的部分抽象，然后采用单向调用的顺序，形成一连串彼此连续的对系统功能的“抽象串”，最终形成对整个系统的完整抽象。

- 分层结构最经典的例子是`Dijkstra 的 THE系统`，它是20世纪60年代在TechnischeHofeschool Eindhoven上开发的。
- 微内核技术是操作系统发展的一个里程碑，它的核心思想是`核心功能外移`。

> 微内核结构用一个水平分层结构代替传统的纵向分层结构的好处
>
> 1. 只要接口规范，操作系统可以方便地增加或者删除服务功能，系统具有良好的灵活性。
> 2. 服务器进程运行在独立的用户进程空间中，如果某个服务器出现问题，不会引起系统其他服务器甚至是系统的崩溃，可靠性好。
> 3. 微内核体积小，便于测试、管理和维护，而且修改服务器的代码也不会影响系统其他部分。
> 4. 由于微内核技术实现了基于客户/服务器体系结构的操作系统，完全适宜于网络环境及分布式计算模型。



### 指令的执行

- 一个单一指令需要的处理称为`指令周期`，一个指令周期可以划分成两个步骤，分别是`取值周期`和`执行周期`。
- 在每个指令周期开始时，处理器从`存储器`中取一条命令。

> 处理器解释指令并执行要求的动作的分类
>
> 1. 处理器与存储器之间的指令或数据传送操作。
> 2. 处理器与I/O设备之间的指令或数据传送操作。
> 3. 算数运算操作或逻辑运算操作。
> 4. 控制操作，即修改指令的执行顺序的操作。

- 程序执行的过程是`反复取指令和执行指令`的过程
- 指令执行的结果就是`使寄存器或内存单元的值发生变化`，指令执行的过程也就是存储体内容不断变化的过程。
- 取指令和执行指令是由`硬件`完成的，不同硬件的体系结构支持不同的指令集合，为某一种硬件平台开发的操作系统不能直接在另一种体系结构的硬件上运行。



## 进程管理

### 进程的描述

- 操作系统中最核心的概念是`进程`，操作系统的其他所有内容都是围绕进程展开的。

> 程序并发执行的特点
>
> 1. 程序的顺序执行。早期误操作系统及单道批处理系统的计算机中，程序的执行方式都是典型的顺序执行。先进入内存的程序先执行，在一个程序执行完毕之前，不能执行其他程序。程序中的指令也是依照程序的控制流依次执行，一条指令执行完毕之前不能开始执行另一条指令。程序顺序执行时具有以下特点：
>    - 顺序性。处理机的操作，严格按照程序所规定的顺序执行，即只有前一操作结束后，才能执行后继操作。
>    - 封闭性。程序是在封闭的环境下运行的。程序一旦开始运行，其结果不受外界因素的影响。
>    - 可再现性。只要程序执行时的环境和初始条件相同，当程序多次重复执行时，其执行结果相同。
> 2. 程序的并发执行。程序并发执行是指在同一时间间隔内运行多个程序。一个程序执行结束之前，可以运行其他程序。对用户而言，看到的是计算机同时运行多个程序。程序并发执行的确切含义是从宏观上，用户看到多个程序同时向前不间断地推进。而从微观上，任意时刻一个CPU上只有一个程序在执行。在现代单CPU或多CPU的计算机中，支持多任务及支持多用户多任务的操作系统都能够有效管理和支持程序的并发执行。多道程序系统和分时系统都允许用户程序在计算机系统中并发执行，程序并发执行具有以下几个特点：
>    - 间断性。每个程序在CPU上运行，都是时断时续的。当请求某种资源的程序数量大于被请求的资源数量时，就必然有因申请不到资源而暂停执行的程序。当其他程序释放资源后，该程序才可能继续执行。资源的有限使并发执行的程序呈现执行过程的间断性。
>    - 失去封闭性。程序在并发执行时，由于它们共享资源或者合作完成同一项任务，系统的状态不再是只有正在执行的某一个程序可以“看见”和改变。
>    - 不可再现性。程序在并发执行时，由于失去了封闭性，也将导致其失去执行结果的可再现性。同一个程序在输入完全的情况下多次运行，可能出现不同的运行结果。

> 进程的特征
>
> 1. 并发性。多个进程实体能在一段时间间隔内同时运行。并发性时进程和现代操作系统的重要特征。
> 2. 动态性。进程是进程实体的执行过程。进程的动态性表现在因执行程序而创建进程、因获得CPU而执行进程的指令、因运行终止而被撤销的动态变化过程。
> 3. 独立性。在没有引入线程概念的操作系统中，进程是独立运行和资源调度的基本单位。
> 4. 异步性。异步性是指进程的执行时断时续，进程什么时候执行、什么时候暂停都是无法预知的，呈现一种随机的特征。
> 5. 结构特征。进程实体包括`用户正文段`、`用户数据段`和`进程控制块`。

> 进程与程序的区别
>
> 1. 程序是静态的，进程是动态的。程序是存储在某种介质上的二进制代码，进程对应了程序执行的过程，系统不需要为一个不执行的程序创建进程，一但进程被创建，就处于不断变化的动态过程中，对应了一个不断变化的上下文环境。
> 2. 程序是永久的，进程是暂时存在的。程序的永久性是相对于进程而言的，只要程序的拥有者不去删除它，程序可以永久地存在于磁盘、U盘等外存储介质中。进程因程序的执行而被创建，因程序执行的结束而被撤销，有一个相对短暂的生命期。
> 3. 程序与进程的存在实体不同。程序是指令的集合，而进程是包括了正文段、用户数据段和进程控制块的实体。

> 进程与程序的联系
>
> 1. 进程是程序的一次执行，进程总是对应至少一个特定的程序，执行程序的代码。
> 2. 一个程序可以对应多个进程。同一个程序可以在不同的数据集合上运行，因而构成若干个不同的进程。几个进程能够并发地执行相同的程序代码，而同一个进程能顺序地执行几个程序。

- 不同操作系统进程控制块中包含的描述信息部完全相同，一般操作系统中的进程控制块中通常包含`进程标识符信息`、`处理机信息`、`进程调度信息`和`进程控制信息`。

> 进程控制块中保留的处理机状态信息
>
> 1. 通用寄存器
> 2. 指令计数器
> 3. 程序状态字PSW
> 4. 用户栈指针

- 进程的3中基本状态：`就绪态`、`执行态`和`阻塞态`。
- 进程状态不能有阻塞态直接变为`执行态`，进程状态由阻塞态变为就绪态的过程称为`唤醒过程`，由执行态变为阻塞态的过程称为`阻塞过程`。



### 进程的控制

> 需要创建新的进程的情况
>
> 1. 用户登录。在交互式系统中，当一个新用户登录系统时会创建进程。
> 2. 作业调度。当把位于外存储器中的作业调入内存准备运行时，操作系统会为作业的运行创建进程，
> 3. 提供服务。操作系统可以创建一个程序，代表用户程序执行某种功能，使用户无需等待。
> 4. 应用请求。当用户发出执行某程序的命令，或者用户程序在执行中基于并行的要求在程序中显式调用进程创建的系统调用时，都会引起进程的创建。

- 在Linux系统中，除了`0号进程（swapper进程）`外的其他进程都是由其父进程创建的。
- 与进程创建密切相关的函数有`execve()`，与其对应的系统调用是sys_execve()，主要功能是使进程执行新的程序代码。

> 操作系统可能进行进程的阻塞和唤醒操作的情况
>
> 1. 请求系统服务
> 2. 启动某种操作
> 3. 新数据尚未到达。对于一个计算进程，如果新的输入数据还没有到达，计算进程需要阻塞等待。
> 4. 无新工作可做。发送消息之后等待时。

> 进程唤醒的过程
>
> 1. 将进程从阻塞队列中移出
> 2. 将进程状态由阻塞态改为就绪态
> 3. 将进程插入就绪队列

> 进程被终止的情况
>
> 1. 当进程正常执行完毕，调用终止进程的系统调用，请求操作系统删除该进程。
> 2. 一个进程调用适当的系统调用，终止另外一个进程。通常，操作系统规定只允许父进程通过这种方式终止其子进程。

- 如果选择硬盘启动，计算机会检查硬盘的`0柱面0磁道1扇区`，如果发现该扇区以`0xAA5`结束，则BIOS认为它是引导扇区，一但发现引导扇区，BIOS会执行程序将其装入到内存地址0000 : 7e00处，然后跳转到该地址处执行这段引导程序代码，开始加载操作系统。



### 操作系统内核

- 资源管理包括`进程管理`、`存储器管理`和`设备管理`。

> 中断的类型
>
> 1. 同步中断（内部中断或异常）。同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步模式因为只有在一条指令终止执行后CPU才会发出中断，如除法出错、调试、溢出和浮点出错等。
> 2. 异步中断（外部中断）。异步中断是由其他硬件设备随机产生的。在Intel微处理器手册中，把同步中断和异步中断分别称为异常（Exception）和中断（Interrupt）。Linux中采用这种分类，有时也用术语”中断信号“来表示这两种类型 的中断（同步中断及异步中断）。

- 大部分PC中有两个时钟源，分别微`实际时钟（RTC）`和`OS时钟`。RTC时钟也称CMOS时钟，是一块时钟芯片，靠`电池`供电，为计算机提供计时标准，是最原始、最底层的数据。OS时钟产生于PC主板上的定时/计数芯片，在开机时有效，由`操作系统`控制。
- `系统调用`是系统程序与用户程序之间的接口。
- 在类UNIX系统中，系统调用多使用`C语言提供的库函数`作为接口

> 系统调用的类型
>
> 1. 进程控制类系统调用。创建、撤销进程；获得、改变进程属性。
> 2. 文件操纵类系统调用。创建文件、删除文件、打开文件、关闭文件和读/写文件。
> 3. 设备管理类系统调用。请求、释放设备。
> 4. 通信类系统调用。打开、关闭连接，交换信息。



### 进程同步

> 同步机制应遵循的准则
>
> 1. 空闲让进
> 2. 忙则等待
> 3. 有限等待
> 4. 让权等待

- `自旋锁`是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁”开着“，就是相应的整型信号量的值`大于0`，就获取锁并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径”锁着“，即整型信息号量的值`等于0或者小于0`，就反复执行一条紧凑的循环指令，知道锁被释放。
- 整型信号量的值只能由`wait`和`signal`操作改变。
- 管程是一个由`过程`、`变量`和`数据结构`等组成的集合，他们组成一个特殊的模块或软件包。
- 一个管程过程，可以用在某条件变量上执行`wait`操作，将调用管程的进程阻塞并插入该条件的阻塞队列；用在条件变量上执行`signal`操作，唤醒在该条件上阻塞的进程。



### 进程通信

> 共享存储系统的类型
>
> 1. 基于共享数据结构的通信方式
> 2. 基于共享存储区的通信方式

- 在消息传递系统中，根据源进程向目标进程传递消息方式的不同，可分为`直接通信方式`和`间接通信方式`。
- `管道文件`存在于外存中，其中的信息没有固定的长度，能用于进程间大量的信息通信。
- 消息缓冲区是一个结构型数据结构，通常包括`发送进程标志符`、`消息长度`、`消息正文`和`指向下一个消息缓冲区的指针`
- 消息缓冲队列需要被当作临界资源，在发送原语和接收原语中对消息缓冲队列的访问需要进行`互斥与同步`。



### 线程

- 线程在运行中呈现间断性，有`就绪`、`阻塞`和`执行`3种基本状态。
- 线程的视线可以分为两类，即`用户级线程`和`内核级线程`。

> 引起线程终止的原因
>
> 1. 正常结束
> 2. 异常结束
> 3. 外界干预

> 线程终止的过程
>
> 1. 根据被终止线程的标识符，从TCB集合中检索出该线程的TCB，从中读出该线程的状态。
> 2. 若被终止线程正处于运行状态，应立即终止该线程的执行，并置调度标志为真，用于指示该线程被终止后应重新执行线程调度程序。
> 3. 将被终止线程的TCB从所在队列（或链表）中移出，等待其他程序来搜集信息。

> 用户线程的阻塞过程
>
> 1. 停止该线程的执行，将该线程的状态改为阻塞态。
> 2. 将该线程控制块插入相应的线程阻塞队列。
> 3. 将该线程所属进程的状态改为阻塞态。
> 4. 将该线程所属的进程的进程控制块插入相应的进程阻塞队列。
> 5. 将控制传递给进程调度程序，重新进行进程调度。

> 用户线程的唤醒进程
>
> 1. 将该线程所属进程的状态由阻塞改为就绪。
> 2. 将该线程所属进程的进程控制块从进程阻塞队列中移出。
> 3. 将该线程所属进程的进程控制块插入进程就绪队列。
> 4. 将该线程状态由阻塞改为就绪。
> 5. 将该线程的线程控制块从线程阻塞队列中移出。
> 6. 将线程的线程控制块插入线程就绪队列。

> 内核线程的阻塞过程
>
> 1. 停止该线程的执行，将该线程的状态改为阻塞态。
> 2. 将该线程控制块插入相应的线程阻塞队列。
> 3. 将控制传递给线程调度程序，重新进行线程调度。

> 内核线程的唤醒过程
>
> 1. 将该线程状态由阻塞态改为就绪态。
> 2. 将该线程的线程控制块从线程阻塞队列中移出。
> 3. 将该线程的线程控制块插入线程就绪队列。



## 进程调度与死锁

### 进程调度的功能与时机

- 进程调度功能是由`操作系统内核的进程调度程序`完成，在Linux内核中，进程调度功能的视线从`调用内核函数schedule()`开始。进程调度的功能是按照某种策略和算法从就绪态进程（在Linux中是可执行进程）中为当前空闲的CPU选择在其上运行的新进程。

> 进程调度的时机
>
> 当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中有比当前运行进程优先级更高的进程到来、当前运行进程的时间片用完时，系统都会通过执行进程调度程序重新进行进程调度。



### 进程调度算法

> 选择调度方式和算法的若干准则
>
> 1. 周转时间短
> 2. 响应时间快
> 3. 截止时间的保证
> 4. 系统吞吐量高
> 5. 处理机利用率好

- 优先权调度算法的一个主要问题是`无穷阻塞`，或称饥饿问题。
- 低优先权进程无穷等待问题的解决方案之一是`老化技术`。

> 多级反馈队列算法的设计要考虑的问题
>
> 1. 就绪队列的数量
> 2. 根据进程优先权确定进程应该进入哪一个就绪队列的算法
> 3. 用以确定进程何时转移到较高优先队列的算法
> 4. 用以确定进程何时转移到较低优先队列的算法
> 5. 用以确定进程在需要服务时应该进入那个队列的算法



### 实时系统中的调度

- 实现实时调度的基本条件有：`提供必要的调度信息`、`系统处理能力强`、`采用抢占式调度机制`和`具有快速切换机制`。

> 为了实现实时调度，系统可能需要为调度程序提供的信息
>
> 1. 就绪时间，是一个实时任务成为就绪态的起始时间。
> 2. 开始截止时间和完成截止时间。
> 3. 处理时间，指一个实时任务从开始执行直到完成所需要的时间。
> 4. 资源要求。关于任务执行所需要的资源信息。
> 5. 优先级。根据实时任务紧迫程度的不同，可以给实时任务赋予不同的优先权，使较高优先权先获得系统资源，尽快得到执行。系统中实时进程的优先权不能动态降低。

- 快速切换机制应具有的能力包括`对外部中断的快速响应能力`、`快速的进程切换能力`。
- `松弛度`用来表示一个实时进程的紧迫程度。



### 进程切换

> 进程切换的步骤
>
> 1. 保存包括程序计数器和其他寄存器在内的CPU上下文环境。
> 2. 更新被替换进程的进程控制块。
> 3. 修改进程状态，把执行态改为就绪态或阻塞态。
> 4. 将被替换进程的进程控制块移动就绪队列或阻塞队列。
> 5. 执行通过进程调度程序选择的新进程，并更新该进程的进程控制块。
> 6. 更新内存管理的数据结构。
> 7. 恢复被调度程序选中的进程的硬件上下文。



### 多处理器调度

- 对处理器系统有多种不同的分类方式，根据处理器的耦合程度，可以把多处理器系统分为`紧密耦合多处理器系统`和`松弛耦合多处理器系统`；根据处理器结构是否相同，可以把多处理器系统分为`对称多处理器系统`和`非对称多处理器系统`。
- 紧密耦合的多处理器系统通常通过`高速总线或高速交叉开关`实现多个处理器之间的互连，它们共享主存储器系统和I/O设备，并要求将主存储器划分为若干个独立访问的存储区模块，以便多个处理器能够同时对主存进行访问。
- 在对称多处理器系统中，静态分配方式的优点是`进程调度的开销小`，缺点是`不能动态平衡各处理器的负载，使系统存在各处理器忙闲不均的情况`。
- 动态分配的基本特征就是`每个进程经过多次调度，每次获得的不一定是同一个处理器`。
- 自调度算法的优点是`易移植`和`有利于提高CPU的利用率`。
- 自调度方式的缺点是`瓶颈问题`、`低效性`和`线程切换频繁`。
- 专用处理器的优点是`加速了应用程序的运行速度`、`避免了进程的切换`。



### 死锁

- 产生死锁的原因是`竞争共享资源且分配资源的顺序不当`。

> 产生死锁的必要条件
>
> 1. 互斥条件。互斥条件指一个进程在访问资源的过程中，其他进程不能访问该资源。
> 2. 请求和保持条件。进程已经保持了至少一个资源，由提出了新的资源要求，而新请求的资源已经被其他进程占用，此时进度阻塞但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。
> 3. 不剥夺条件。进程已经获得的资源不能被剥夺，只能由进程自己释放。
> 4. 环路等待条件。在发生死锁时，必然存在一个进程申请资源的环形链。

- 处理死锁的基本方法有：`预防死锁`、`避免死锁`、`检测并解除死锁`和`忽略死锁问题`。
- 预防死锁可以通过摒弃`请求和保持条件`、`不剥夺条件`和`环路等待条件`之一来实现。
- 摒弃环路等待的方法是指`进程必须按规定的顺序申请资源`。
- 解除死锁的途径有两个：一是`终止处于死锁状态的进程`，二是`抢占死锁进程占有的资源`。

> 在采用终止部分进程的方式时需要考虑的因素
>
> 1. 进程的优先级是什么？
> 2. 进程已执行了多久？进程在完成其指定任务之前还需要多长时间？
> 3. 进程使用了多少资源？分别是什么类型的资源？这些资源是否容易被抢占？
> 4. 进程需要多少资源才能完成？
> 5. 需要终止多少进程才能解除死锁？
> 6. 进程是交互的还是批处理的？



## 内存管理

### 存储器的层次结构

- `CPU寄存器`保存最常用的数据。
- 如果程序需要的数据是存放在CPU寄存器中的，程序执行期间在`零`个周期内就可以访问到它们。
- 程序的执行遵循`局部性`原理

> 关于程序执行的局限性原理的几个论点
>
> 1. 程序在执行时，除了少部分的转移和过程调用指令以外，在大多数情况下是顺序执行的。
> 2. 过程调用将会使程序的执行轨迹由一部分内存区域转移到另一部分内存区域。
> 3. 程序中存在很多循环结构，它们虽然由少数指令构成，但多次执行。
> 4. 程序中往往包括许多对数据结构的处理

- 局限性原理表现为`时间和空间`的局限性。



### 程序的链接和装入

- 链接程序要解决的问题是`将编译后的目标模块装配成一个可执行的程序`。
- 根据链接进行的时间和现实方法的不同，可以把链接分为`静态链接`和`动态链接`。
- `静态链接`是在程序运行前，用链接程序将目标模块链接成一个完成的装入模块。
- 静态链接程序的任务一是`对逻辑地址进行修改`，二是`变换外部调用符号`。
- 采用动态链接的优点是`节省内和外存空间，方便了程序开发`。
- 多数系统允许操作系统将`用户进程`放在屋里内存的任意位置。
- 根据形成在内存中物理地址的时机不同，把程序的装入方法分为`绝对装入方式`、`可重定位装入方式（静态重定位）`和`动态运行时装入`方式。
- 在程序装入时对目标程序中的指令和数据地址的修改过程称为`重定位`。

> 可重定位方式的两个特点
>
> 1. 编译程序使目标模块的起始地址从 0 开始
> 2. 程序装入时，装入程序根据内存的使用情况将装入模块转入到内存的某个为止，并对模块进行重定位。

- 一个进程在被换出之前所在的内存为止与后来被人从外存重新调入内存时所在的位置不同，在这种情况下，地址映射必须延迟到进程执行时再进行，把这种装入方式称为`动态运行时装入`。



### 连续分配存储管理方法

- 连续分配是指操作系统分配内存时，为每个进程分配一块`物理地址连续`的内存空间。
- 连续分配方式有`单一连续区分配方式`、`固定分区分配方式`和`动态分区分配方式`3中类型。
- 在单用户、单任务操作系统中较常用的方法是`设置一个基址寄存器和一个界限寄存器`。
- `基址寄存器`中存放程序在物理内存中的最小地址，界限寄存器中存放装入用户区程序的地址范围。

> 有些单用户、单任务的操作系统没有设置存储器保护机制的原因
>
> 1. 节省硬件
> 2. 单任务单用户系统中，用户独占机器，对系统的破坏只可能是用户自己造成的，后果也不严重，不会影响其他用户程序的执行，而且操作系统容易重装和再次启动。

- 使用`固定分区`分配内存利用率低，难以提高系统的多道程序度。
- 动态分区分配是根据`进程的实际需要`，为进程分配大小合适的内存区域。
- 系统中用户分区的数量和大小都是`动态变化的`。
- 动态分区分配算法包括`首次适应算法`、`循环首次适应算法`和`最佳适应算法`。
- 循环首次适应算法的优点是`空间区分均匀`、`查找开销较小`，缺点是`容易使系统缺乏大空闲区`。
- 最佳适应算法的优点是`避免了大材小用，能提高内存利用率`，缺点是采用最佳适应算法`容易留下难以利用的小空闲区`。



### 基本分页存储管理方式

- 把进程离散地存储在内存中物理地址不连续的区域中，这种内存管理方式称为`离散内存管理方式`。
- 根据离散内存管理分配内存空间的基本单位的不同，将其分为3种不同的管理方式：`分页存储管理`、`分段存储管理`和`段页式存储管理`。
- 将一个进程的逻辑地址空间分成若干个大小相等的片，称为`页`。
- 将物理内存空间分成与页大小相同的若干个存储块，称为`页框或页帧`。
- 在为进程分配内存时，以`页框`为单位将进程中的若干页分别装入多个可以不相邻接的页框中。
- 进程的最后一页一般装不满一个页框，而形成了不可利用的碎片，称为`页内碎片`，是一种内部碎片。
- 页表是系统为进程建立的数据结构，页表的作用是`实现从页号到页框号的映射`。

> 影响页大小设计的因素
>
> 1. 管理内存的开销。选择较小的页，会导致进程被划分为较多的页，页表过长，占用大量内存空间。同时，进程的缺页率和置换率都会比较高，内存管理的时间开销相对大。
> 2. 内存的利用率。选择较小的页，有利于提高内存的利用率，但存在（1）所述的缺点，选择较大的页，可克服（1）所述的缺点，但页内碎片大，空间利用率低。

- `快表`也称转换后援缓冲（TLB），是为了提高CPU访存速度而采用的专用缓存，用来存放最近被访问过的页表项。
- TLB是`关键的快速内存`。TLB的条目由两部分组成：`键`和`值`。键部分对应`页号`，值部分对应`页所在的页框号`。

> 引入TLB之后的地址变换过程
>
> 1. CPU产生分页的逻辑地址页号和页内偏移后，将该逻辑地址的页号提交给TLB。
> 2. 查找TLB，如果找到页号，则把该页所在的页框号用于形成物理地址。否则（TLB失效）查找内存页表，从内存页表中找到相应的页表项，读取页所在的页框号，以形成物理地址。
> 3. 如果所查找的页表项不在TLB中，在访问完内存页表后，要把找到的页表项中的页号和页框号写到TLB中。如果TLB中的条目已满，系统会根据某种策略（如最近最少使用替换）选择一个TLB中的条目，用刚访问的页表项信息替换选中的这个TLB条目。

- 当系统支持的逻辑空间很大时，意味着系统允许每个进程的逻辑地址空间`很大`。
- 使用两级页表的系统，当进程切换时，要运行的进程的页目录表起始地址被写入CPU寄存器，可以称之为`页表寄存器`。

> 在两级页表的寻址中，地址映射的过程如下
>
> 1. 对于给定的逻辑地址A，由硬件从中分离处页目录号p1、页号p2和页内地址d。
> 2. 由页表寄存器的值和页目录号p1，从存放页目录的页框中找到页表所在的页框号。`页表所在的页框号在内存中的地址 = 页目录起始地址 ＋ p1 × 页表项长度`，从该地址指示的物理内存单元中读取页表所在的页框号。
> 3. 由页表所在的页框号和页号p2，从存放页表的页框中找到进程页所在的页框号。`进程页所在的页框号在内存中的地址 = 页表的其实地址 + p2 × 页表项长度`。`页表的起始地址 = 页表所在的页框块号 × 页框大小`。
> 4. `A的物理地址 = 进程页所在的页框号 × 页框大小 + 页内地址d`

- `空闲页框链表`可以按地址递增的顺序排序，每个结点中包括页框的地址信息、指向后面结点的指针和指向前面结点的指针。



### 基于分页的虚拟存储系统

- `虚拟存储器`是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。
- 虚拟存储技术实现的基本思想是`☞把进程的一部分装入内存`。

> 虚拟内存技术能带来的好处
>
> 1. 提高内存利用率。因为虚拟存储技术允许只把进程的一部分装入内存，原则上尽量把必须或常用部分装入内存，
> 2. 提高多道程序度。因为只把每个进程的一部分装入内存，因此可以在内存中装入更多的进程。
> 3. 把逻辑地址空间和物理地址空间分开，是程序员不用关心物理内存的容量对编程的限制。

> 虚拟存储系统的主要特征
>
> 1. 离散性。离散性是指进程可以分散地存储在物理内存中。
> 2. 多次性。多次性是指不必把进程一次性全部装入内存，可以先将执行当前进程所必须的部分代码和数据装入内存，其余部分等进程运行需要时再装入，卡伊将进程分多次装入内存。
> 3. 对换性。对换性是指在内存中的进程可以换出，以腾出内存空间存入外存中的进程。
> 4. 虚拟性。虚拟性是指虚拟存储系统为用户提供了比实际物理内存大的逻辑内存空间，是程序员不必再编程时受物理内存空间大小的限制。虚拟性是实现虚拟存储系统的最重要的目标。

- 页表是支持请求分页系统最重要的数据结构，其作用是记录描述页的`各种数据`，包括在现实逻辑地址到物理地址映射时需要的页号与页框号的对应关系。除了页号和页框号之外，页表中增加了`请求换入和页置换使需要的数据`。

> 缺页异常机构的具体过程
>
> 缺页异常机构的主要作用是`在访问内存过程中发现缺页产生缺页异常信号，使CPU中断当前控制流的执行，转区执行操作系统的缺页异常处理程序，完成请求调页。`具体过程如下。
>
> 1. 分页硬件通过页表完成逻辑地址到物理地址的映射时，通过检查页表中的状态位P，判断当前被访问的页是否在内存中。如果不在，则产生缺页异常信号。
> 2. 执行操作系统的缺页异常处理过程。现在内存中为请求调入的页找一个空闲页框。然后，调度磁盘操作，把需要的页装入找到的空闲页框中。
> 3. 修改页表，更新已经调入页的存在位、在内存中的页框号、访问位和保护位等字段的值。
> 4. 重新开始执行因缺页而中断的指令。

- 采用平均分配算法为进程分配页框的缺点是`算法不考虑进程规模，可能使大津城分配到的页框与小进程一样多`。
- `FIFO`是最简单的页置换算法。
- 计算机系统要提供足够的硬件来支持LRU算法是比较困难的，许多系统在实现时都采用`LRU的近似算法`，如附加引用位算法、简单的Clock算法和改进型Clock算法等。
- 引起系统抖动的主要原因是`系统中的进程数量太多，每个进程能分配到的页框太少，以至于进程运行中频繁请求调页`。

> 抖动的预防
>
> 1. 采用局部置换策略
> 2. 在CPU调度程序中引入工作集算法
> 3. 挂起若干进程



### 分段存储管理

- 在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示`段`，另一个数用来表述`段内偏移`。
- 在分段的存储管理方式中，进程的地址空间被划分成若干个段。每个段定义了一组逻辑信息，每个段的大小由`相应的逻辑信息组的长度`确定，段的大小不一样，每个段的逻辑地址从`0`开始，采用一段连续的地址空间。

> 若已知逻辑单元的地址为s : d，求相应物理地址的步骤如下
>
> 1. 以段号 s 作为索引，从段表中找到段号为 s 的段表项
> 2. 从找到的段表项中读出 s 段的基地址和段大小
> 3. 如果 d <= 段大小，则将段基址与段内偏移 d 相加，得到与逻辑单元 s : d 相应的物理单元地址

> 分页和分段的主要区别
>
> 1. 页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段时按逻辑单位划分的，一个段含有一组意义相对完整的信息。引入分段的目的是为了方便程序员编程。
> 2. 页的大小是固定的。而段的大小不固定，取决于用户编写的程序和编译器。
> 3. 分页的地址空间时一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个数。分段的地址空间时二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移。

> 地址变换过程
>
> 在段页式存储管理系统中，逻辑地址于分段系统的逻辑地址相同，由段号 s 和段内偏移地址 d 构成，地址变换过程如下。
>
> 1. 以段号 s 作为索引，找到段 s 的段表项，得到该段页表的起始地址。
> 2. 通过分页机制从段内偏移 d 中分离出页号 p 和页内偏移 w。
> 3. 以段内页号 p 作为索引，从段 s 的页表中搜索页号 p 对应的页表项。
> 4. 从页表项中得到页所在的页框号。
> 5. 由页框号于页内偏移 w 得到某逻辑地址对应的物理地址。



### Linux的伙伴系统

- `Linu的伙伴系统`算法把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、63、128、256、512和1024个连续的页框。对1024个页框的最大小请求对应着`4MB大小的连续页框`。每个块的第一个页框的物理地址是`该块大小的整数倍`。
- 内核试图把大小为 b 的一对空闲伙伴合并为一个大小为`2b`的单独块。

> 两个块称为伙伴需要满足的条件
>
> 1. 两个块具有相同搞得大小，记作 b。
> 2. 他们的物理地址是连续的，起始地址是2b的整数倍。