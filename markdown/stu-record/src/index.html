<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>index</title>
<link rel="stylesheet" href="./public/MarkdownPad2AutoCatalog.css"><link rel="stylesheet" href="./public/index.css"></head>
<body><h1 id='study-record'>study record</h1>
<h2 id='git'>git</h2>
<p>&nbsp;</p>
<h3 id='分支操作'>分支操作</h3>
<ol start='' >
<li>创建分支
<code>git branch &quot;Branch Name&quot;</code></li>

</ol>
<ul>
<li>查看所有分支记录
<code>git branch -a</code></li>
<li>删除分支
<code>git branch -D &quot;Branch Name&quot;</code></li>
<li>删除远程连接分支
<code>git push origin --delete &quot;Branch Name&quot;</code></li>

</ul>
<ol start='2' >
<li>切换分支
<code>git checkout &quot;Branch Name&quot;</code></li>
<li>上传</li>

</ol>
<ul>
<li><p>单独上传 切换到需要上传的分支进行上传</p>
</li>
<li><p>合并上传</p>
<ul>
<li>合并分支 需切换到主分支
<code>git merge &quot;Branch Name&quot;</code></li>
<li>合并分支 增加日志
<code>git merge &quot;Branch Name&quot; -m &quot;log Name</code></li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<h3 id='日常使用'>日常使用</h3>
<ol start='' >
<li>创建仓库</li>
<li>Git Bash Here</li>

</ol>
<ul>
<li>创建本地仓库
<code>git init</code></li>

</ul>
<ol start='3' >
<li>添加文件至暂存区
<code>git add &lt;fliename&gt;</code>
<code>git add .</code></li>

</ol>
<ul>
<li>查看暂存区状态 项目提交仓库后无法查看
<code>git status</code></li>

</ul>
<ol start='4' >
<li>配置本地仓库
<code>git config --global user.email &quot;you@example.com&quot;</code>
<code>git config --global user.name &quot;Your Name&quot;</code></li>
<li>创建项目至本地仓库
<code>git commit -m &quot;log name&quot;</code></li>

</ol>
<ul>
<li>查看日志列表
<code>git log</code></li>

</ul>
<ol start='6' >
<li>项目更新/拉取远程代码合并
<code>git pull</code>
<code>git pull --rebase origin master</code></li>

</ol>
<ul>
<li>克隆项目
<code>git clone &quot;Project Address&quot;</code></li>

</ul>
<ol start='7' >
<li>本地仓库同步至远程服务器</li>

</ol>
<ul>
<li>连接远程
<code>git remote add origin &quot;Remote Address&quot;</code></li>
<li>删除之前的远程仓库链接
<code>git remote rm origin</code></li>
<li>上传项目
<code>git push -u origin master</code></li>
<li>强制提交 会覆盖远程文件
<code>git push -f origin master</code></li>

</ul>
<p>&nbsp;</p>
<h3 id='项目版本'>项目版本</h3>
<ol start='' >
<li><p>查看当前版本</p>
<p><code>git show</code></p>
</li>
<li><p>回到上个版本 </p>
<p><code>git reset --hard HEAD^</code></p>
</li>
<li><p>查看所有版本号</p>
<p><code>git reflog</code></p>
</li>
<li><p>回退到指定版本</p>
<p><code>git reset --hard &quot;reflog vesion&quot;</code></p>
</li>

</ol>
<p>&nbsp;</p>
<h3 id='其他命令'>其他命令</h3>
<ol start='' >
<li>查看当前文件与暂存区文件区别
<code>git diff</code></li>
<li>回撤所有文件</li>

</ol>
<ul>
<li>如果已经向暂存区添加了项目，必须先回撤在撤销
<code>git checkout --.</code></li>
<li>回撤add 取消暂存区文件
<code>git reset HEAD.</code></li>
<li>回撤指定文件到上一个版本
<code>git checkout --&quot;fileName&quot;</code></li>

</ul>
<ol start='3' >
<li>生成SSH密钥
<code>ssh-keygen -t rsa -C &quot;you@example.com&quot;</code></li>
<li>查看密钥
<code>cat ~/.ssh/id_rsa.pub</code></li>
<li>.gitignore文件 限制上传文件/文件夹</li>

</ol>
<p>&nbsp;</p>
<h2 id='javascript'>javascript</h2>
<p>&nbsp;</p>
<h3 id='递归思路'>递归思路</h3>
<pre><code class='language-javascript' lang='javascript'>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

function sum (list, i = 0) {
  if (i === list.length) return 0
  return list[i] + sum(list, i+1)
}

console.log(&#39;sum&#39;, sum(arr)); // 55
</code></pre>
<p>&nbsp;</p>
<h3 id='斐波那契'>斐波那契</h3>
<pre><code class='language-javascript' lang='javascript'>// Todo: 斐波那契 [1，1，2，3，5，8，13，21，34，55，89]
class Fibonacci {
  first (i) {
    if (i &lt; 2) return 1
    const arr = [1, 1]
    for (let j = 2; j &lt;= i; j++) {
      arr[j] = arr[j - 1] + arr[j - 2]
    }

    return arr[i]
  }

  two (i) {
    if (i &lt; 2) return 1
    let num1 = 1, num2 = 1, num3
    for (let j = 2; j &lt;= i; j++) {
      num3 = num1 + num2
      num1 = num2
      num2 = num3
    }

    return num3
  }
}

console.log(new Fibonacci().first(9)); // On ==&gt; 55
console.log(new Fibonacci().two(9)); // O1 ==&gt; 55
</code></pre>
<p>&nbsp;</p>
<h3 id='class-to-function'>class to function</h3>
<pre><code class='language-javascript' lang='javascript'>// class
class ModeDom {
  constructor (name) {
    this.name = name
  }

  func () {
    console.log(this.name);
  }
}

// Todo: Class constructor ModeDom cannot be invoked without &#39;new&#39;
// ModeDom(&#39;abc&#39;)

// Todo: key only name
// const e = new ModeDom(&#39;abc&#39;)
// for (const key in e) {
//   console.log(key);
// }

// Todo: e.func is not a constructor
// const e = new ModeDom(&#39;abc&#39;)
// new e.func()
</code></pre>
<pre><code class='language-javascript' lang='javascript'>&#39;use strict&#39;;

function ModeDom (name) {
  // Todo: 验证this指向
  if (!(this instanceof ModeDom)) {
    throw new TypeError(`Class constructor ModeDom cannot be invoked without &#39;new&#39;`)
  }
  this.name = name
}

Object.defineProperty(ModeDom.prototype, &#39;func&#39;, {
  value: () =&gt; {
    // Todo: 验证this指向, 不可被new调用
    if (!(this instanceof ModeDom)) {
      throw new TypeError(`Class constructor ModeDom cannot be invoked without &#39;new&#39;`)
    }
    console.log(this.name);
  },
  enumerable: false /// Todo: 不可被枚举
})
// ModeDom.prototype.func = () =&gt; {
//   console.log(this.name);
// }

// Todo: Class constructor ModeDom cannot be invoked without &#39;new&#39;
// ModeDom(&#39;abc&#39;)

// Todo: key only name
// const e = new ModeDom(&#39;abc&#39;)
// for (const key in e) {
//   console.log(key);
// }

// Todo: e.func is not a constructor
// const e = new ModeDom(&#39;abc&#39;)
// new e.func()
</code></pre>
<p>&nbsp;</p>
<h2 id='具体优化'>具体优化</h2>
<p>&nbsp;</p>
<h3 id='html滚动优化'>html滚动优化</h3>
<blockquote><p>Pc端</p>
</blockquote>
<pre><code class='language-css' lang='css'>/* 禁止在页面滚动时鼠标频繁触发事件 */
body {
  pointer-events: none;
}
</code></pre>
<pre><code class='language-javascript' lang='javascript'>let timer = null

window.addEventListener(&quot;scroll&quot;, function () {
  // 滚动时禁用鼠标事件
  document.body.style.pointerEvents = &#39;none&#39;;
  if (timer) { clearTimeout(timer) }
  timer = setTimeout(() =&gt; {
    // 释放
    document.body.style.pointerEvents = &#39;auto&#39;;
  }, 100);
})
</code></pre>
<blockquote><p>移动端</p>
</blockquote>
<pre><code class='language-css' lang='css'>/* 阻止原生touch事件只允许进行滚动和持续缩放操作 */
html {
  touch-action: manipulation;
}
</code></pre>
<pre><code class='language-javascript' lang='javascript'>// 在需要时主动触发对全局的手势禁用
document.documentElement.style.touchAction = &#39;none&#39;
// 或者独立禁用某一片区域的手势操作
document.getElementById(&#39;xxx&#39;).style.touchAction = &#39;none&#39;
// 不需要时还原，例如在抬手事件中处理
document.addEventListener(&#39;touchend&#39;, function (event) {
  // 或 auto
  document.documentElement.style.touchAction = &#39;manipulation&#39;
});
</code></pre>
<p>&nbsp;</p>
<h2 id='奇思妙想'>奇思妙想</h2>
<h3 id='11-透明图片'><code>1:1</code> 透明图片</h3>
<pre><code class='language-html' lang='html'>&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot;&gt;
</code></pre>
<p>&nbsp;</p>
<h2 id='同源--跨域'>同源 &amp; 跨域</h2>
<h3 id='常见的跨域场景'>常见的跨域场景</h3>
<ol start='' >
<li>同一域名，不同端口</li>
<li>同一域名，不同协议（http、https）</li>
<li>域名和域名对应的IP</li>
<li>主域相同，子域不同</li>
<li>同一域名，不同二级域名</li>
<li>不同域名</li>

</ol>
<p><strong>注意</strong></p>
<ul>
<li>协议和端口造成的跨域问题，前台是无能为力的</li>
<li>在跨域问题上，仅仅通过“URL”的首部来识别而不会根据域名对应的IP地址是否相同来判断</li>
<li>跨域不是请求发不出去，而是浏览器把请求回来的数据拦截了</li>

</ul>
<p>&nbsp;</p>
<h3 id='跨域同源'>跨域同源</h3>
<blockquote><p>同源策略是浏览器最核心也是最基本的安全策略。如果缺少同源策略，浏览器会很容易受到XSS、CSFR等攻击。所谓同源，指<code>协议</code>、<code>域名</code>、<code>端口</code>三者相同，其中有一个不同就是不同源。</p>
</blockquote>
<p><strong>注意：下面几种情况不受同源策略限制</strong></p>
<ol start='' >
<li>页面中的链接（例如页面中的a标签链接）</li>
<li>重定向</li>
<li>表单提交</li>
<li>跨域资源的引入，但是js读不到其中的资源（script标签、img标签、link标签、iframe标签）</li>

</ol>
<blockquote><p>同源策略限制的内容</p>
<ol start='' >
<li>Cookie、LocalStorage、IndexDB等存储内容</li>
<li>DOM节点</li>
<li>AJAX请求拦截</li>

</ol>
</blockquote>
<p>&nbsp;</p>
<h3 id='cors'>CORS</h3>
<ul>
<li>CORS需要浏览器和后断同时支持，IE8、IE9需要通过XDomainRequest来实现。</li>
<li>浏览器会自动进行CORS，只要后端实现了CORS，就实现了跨域</li>
<li>服务端设置Access-Control-Allow-Origin</li>

</ul>
<p>&nbsp;</p>
<h3 id='jsonp'>JSONP</h3>
<blockquote><p>利用<code>scipt</code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态生产的JSON数据</p>
</blockquote>
<p><strong>JSONP 请求一定需要对方的服务器支持</strong></p>
<ul>
<li>AJAX属于同源策略，与JSONP相反</li>
<li>JSONP兼容性好，但仅支持GET方法，具有局限性</li>

</ul>
<pre><code class='language-javascript' lang='javascript'>function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) =&gt; {
    let script = document.createElement(&quot;script&quot;);
    window[callback] = function (data) {
      resolve(data);
      document.body.removeChild(script);
    }
    params = [...params, callback];
    let arrs = [];
    for(let key in params) {
      arrs.push(`${key}=${params[key]}`);
    }
    script.src = `${url}?${arrs.join(&quot;&amp;&quot;)}`;
    document.body.appendChild(script);
  })
}
</code></pre>
<blockquote><p>Jquery的JSONP</p>
<p>在使用Jquery发送AJAX时， 设置 <code>dataType: jsonp</code></p>
</blockquote>
<p>&nbsp;</p>
<h3 id='nginx-反向代理'>nginx 反向代理</h3>
<blockquote><p>实现原理类似于Node中间件代理，需要搭建一个nginx反向代理服务器，用于转发请求。支持所有的浏览器，支持session。</p>
</blockquote>
<p>&nbsp;</p>
<h3 id='node-中间件代理'>node 中间件代理</h3>
<ol start='' >
<li>接收客户端请求</li>
<li>将请求发送服务器</li>
<li>拿到服务器响应数据</li>
<li>将数据返回给客户端</li>

</ol>
<p>&nbsp;</p>
<h3 id='postmessage'>postMessage</h3>
<blockquote><p>H5中XMLHttpLevel2中的API，可以跨域操作的window属性之一</p>
<p>postMessage方法允许来自不同源的脚本采用异步方式进行有限的通讯，可以实现跨文本文档，多窗口，跨域传递信息</p>
</blockquote>
<ol start='' >
<li>页面和其他打开的新窗口的数据传输</li>
<li>多窗口之间的信息传递</li>
<li>页面与嵌套的iframe的消息传递</li>
<li>上面三个场景的跨域数据传递</li>

</ol>
<pre><code class='language-javascript' lang='javascript'>otherWindow.postMessage(message, targetOrigin, [transfer])
</code></pre>
<ul>
<li>message：要发送到其他window的数据</li>
<li>targetOrigin：通过origin属性来指定那些窗口能够接收消息事件，其值为字符串<code>*</code>表示无限制，如果目标窗口的协议、主机地址或者端口号有任意不匹配，就不会发送消息</li>
<li>transfer（可选）：Transferable对象，这些对象的所有权被转移给消息的接收方，发送方不保留所有权</li>

</ul>
<pre><code class='language-html' lang='html'>&lt;!-- a.html --&gt;
&lt;iframe src=&quot;http://localhost:400/b.html&quot; frameborder=&quot;0&quot; id=&quot;iframe&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  function load() {
    let frame = document.getElementById(&quot;iframe&quot;);
    frame.contentWindow.postMessage(&quot;iloveyou&quot;, &quot;http://localhost:400&quot;);
    window.onmessage = function (e){
      console.log(e.data); //no
    }
  }
&lt;/script&gt;

&lt;!-- b.html --&gt;
&lt;script&gt;
  window.onmessage = function(e) {
    console.log(e.data); // iloveyou
  }
  e.source.postMessage(&quot;no&quot;, e.origin)
&lt;/script&gt;
</code></pre>
<p>&nbsp;</p>
<h3 id='websocket'>websocket</h3>
<blockquote><p>websocket是h5的一个持久化协议，实现了浏览器与服务器的全双工通信，其与HTTP都基于TCP协议</p>
<p>websocket是一种双向通信协议，在建立连接之后，websocket的server与client都能主动向对方发送或接收数据</p>
</blockquote>
<p>&nbsp;</p>
<h3 id='windowname--iframe'>window.name + iframe</h3>
<blockquote><p>window.name属性值在不同的页面（甚至不同的域名）加载后依旧存在，并且可以支持非常的时间，大小为2MB。</p>
<p>类似的还有 location+hash+iframe、document.domain+iframe</p>
</blockquote>
<p>&nbsp;</p>
<h2 id='面试理论'>面试理论</h2>
<h3 id='浏览器渲染机制'>浏览器渲染机制</h3>
<table border="1">
  <thead>
    <tr>
      <th colspan="3">浏览器</th>
    </tr>
  </thead>
	<tr>
    <td rowspan="9">浏览器进程</td>
    <td>主进程(Browser Process)</td>
    <td>负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。</td>
	</tr>
  <tr>
    <td>第三方插件进程(Plugin Process)</td>
    <td>每种类型的插件对应一个进程,仅当使用该插件时才创建。</td>
  </tr>
  <tr>
    <td>GPU进程(GPU Process)</td>
    <td>最多只有一个,用于 3D 绘制等</td>
  </tr>
  <tr>
    <td rowspan="6">渲染进程(Renderer Process)</td>
    <td>称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。 </td>
  </tr>
  <tr>
    <td>
      <code>JS引擎线程</code>
    </td>
  </tr>
  <tr>
    <td>
      <code>事件触发线程</code>
    </td>
  </tr>
  <tr>
    <td>
      <code>定时触发器线程</code>
    </td>
  </tr>
  <tr>
    <td>
      <code>异步http请求线程</code>
    </td>
  </tr>
  <tr>
    <td>
      <code>GUI渲染线程</code>
    </td>
  </tr>
</table>
<p>&nbsp;</p>
<blockquote><p>浏览器渲染流程</p>
<ol start='' >
<li>解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件</li>
<li>CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树</li>
<li>布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算</li>
<li>绘制 RenderObject 树 （paint）,绘制页面的像素信息</li>
<li>浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面</li>

</ol>
</blockquote>
<pre><code class='language-mermaid' lang='mermaid'>graph LR
	A(HTML) --&gt; B[HTML Parser]
	D(Dom) --&gt; C[Dom Tree]
	B --&gt; C
	C --&gt; E{Attachment}
	S(Style Sheets) --&gt; F[CSS Parser]
	F --&gt; G[Style Tree]
	G --&gt; E
	E --&gt; H(Render Tree)
	L[Layout] --&gt; H
	H --&gt; P[Painting]
	P --&gt; O(Display)
</code></pre>
<p><a href='https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpNkU-LgzAQxb9KmJMFW7SJbuthoa39c7BsqT2t9hDqtAoaJUZYV_zuq5Fd9vbLey9vYKaDR5kgePCSvEpJcI1FrDbG6XYOZmQ-fyfbaGRy4bJGeR9d3_DLYjJ30YDkJhG1s53EEXca991GKf5ICxSqH-XQCFWbIwlTRFVPJYdoF4b_Bxy0fIym6F_7caocca_xZFxRJCh1ZDbqQRTwtmzUffJH6aTxEl14JlQmXrrqosUPw8_qKuftDEwoUBY8S4ZNdLEgJAaVYoExeAMm-ORNrmKIRT9EeaPKsBUP8JRs0ISmSrhCP-PDDgvwnjyvB7Xi4rMsi9_Q8ASvgy_wbNta2GxpUWdN6WrpOia04FHmLGzXpsxyV2-Ww1hvwrf-by2GEGMus-l6TVfUYSZgkqlSnqfT6Qv2PxHajMM'><img src="https://mermaid.ink/img/pako:eNpNkU-LgzAQxb9KmJMFW7SJbuthoa39c7BsqT2t9hDqtAoaJUZYV_zuq5Fd9vbLey9vYKaDR5kgePCSvEpJcI1FrDbG6XYOZmQ-fyfbaGRy4bJGeR9d3_DLYjJ30YDkJhG1s53EEXca991GKf5ICxSqH-XQCFWbIwlTRFVPJYdoF4b_Bxy0fIym6F_7caocca_xZFxRJCh1ZDbqQRTwtmzUffJH6aTxEl14JlQmXrrqosUPw8_qKuftDEwoUBY8S4ZNdLEgJAaVYoExeAMm-ORNrmKIRT9EeaPKsBUP8JRs0ISmSrhCP-PDDgvwnjyvB7Xi4rMsi9_Q8ASvgy_wbNta2GxpUWdN6WrpOia04FHmLGzXpsxyV2-Ww1hvwrf-by2GEGMus-l6TVfUYSZgkqlSnqfT6Qv2PxHajMM?type=png" referrerpolicy="no-referrer" alt="浏览器渲染流程"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id='markdown-高级语法'>Markdown 高级语法</h2>
<h3 id='书写一个质能守恒公式latex'>书写一个质能守恒公式<sup class='md-footnote'><a href='#dfref-footnote-1' name='ref-footnote-1'>1</a></sup></h3>
<p>$$E=mc^2$$</p>
<p>&nbsp;</p>
<h3 id='画一个图'>画一个图</h3>
<h4 id='横向流程图源码样例'>横向流程图源码样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>graph LR
A[方形] --&gt;B(圆角)
    B --&gt; C{条件a}
    C --&gt;|a=1| D[结果1]
    C --&gt;|a=2| E[结果2]
</code></pre>
<h4 id='竖向流程图源码样例'>竖向流程图源码样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>graph TD
A[方形] --&gt; B(圆角)
    B --&gt; C{条件a}
    C --&gt; |a=1| D[结果1]
    C --&gt; |a=2| E[结果2]
</code></pre>
<h4 id='标准流程图源码样例'>标准流程图源码样例</h4>
<pre><code class='language-flow' lang='flow'>st=&gt;start: Start
op=&gt;operation: Your Operation
cond=&gt;condition: Yes or No?
e=&gt;end
st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st-&gt;op-&gt;cond
cond(yes)-&gt;io-&gt;e
cond(no)-&gt;sub1(right)-&gt;op
</code></pre>
<h4 id='标准流程图源码样例横向）'>标准流程图源码样例（横向）</h4>
<pre><code class='language-flow' lang='flow'>st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st(right)-&gt;op(right)-&gt;cond
cond(yes)-&gt;io(bottom)-&gt;e
cond(no)-&gt;sub1(right)-&gt;op
</code></pre>
<h4 id='uml时序图源码样例'>UML时序图源码样例</h4>
<pre><code class='language-sequence' lang='sequence'>对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象A-&gt;对象B: 你真的好吗？
</code></pre>
<h4 id='uml时序图源码复杂样例'>UML时序图源码复杂样例</h4>
<pre><code class='language-sequence' lang='sequence'>Title: 标题：复杂使用
对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象B-&gt;小三: 你好吗
小三--&gt;&gt;对象A: 对象B找我了
对象A-&gt;对象B: 你真的好吗？
Note over 小三,对象B: 我们是朋友
participant C
Note right of C: 没人陪我玩
</code></pre>
<h4 id='uml标准时序图样例'>UML标准时序图样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
  sequenceDiagram
    participant 张三
    participant 李四
    张三-&gt;王五: 王五你好吗？
    loop 健康检查
        王五-&gt;王五: 与疾病战斗
    end
    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...
    李四--&gt;&gt;张三: 很好!
    王五-&gt;李四: 你怎么样?
    李四--&gt;王五: 很好!
</code></pre>
<h4 id='甘特图样例'>甘特图样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>    gantt
    dateFormat  YYYY-MM-DD
    title 软件开发甘特图
    section 设计
    需求                      :done,    des1, 2014-01-06,2014-01-08
    原型                      :active,  des2, 2014-01-09, 3d
    UI设计                     :         des3, after des2, 5d
未来任务                     :         des4, after des3, 5d
    section 开发
    学习准备理解需求                      :crit, done, 2014-01-06,24h
    设计框架                             :crit, done, after des2, 2d
    开发                                 :crit, active, 3d
    未来任务                              :crit, 5d
    耍                                   :2d
    section 测试
    功能测试                              :active, a1, after des3, 3d
    压力测试                               :after a1  , 20h
    测试报告                               : 48h
</code></pre>
<h4 id='类图样例'>类图样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>classDiagram
	Animal &lt;|-- Duck
	Animal &lt;|-- Fish
	Animal &lt;|-- Zebra
	Animal : +int age
	Animal : +String gender
	Animal: +isMammal()
	Animal: +mate()
	class Duck{
		+String beakColor
		+swim()
		+quack()
	}
	class Fish{
		-int sizeInFeet
		-canEat()
	}
	class Zebra{
		+bool is_wild
		+run()
	}
</code></pre>
<h4 id='饼图样例'>饼图样例</h4>
<pre><code class='language-mermaid' lang='mermaid'>pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>

<div class='footnotes-area'  ><hr/>
<div class='footnote-line'><span class='md-fn-count'>1</span> 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。 <a name='dfref-footnote-1' href='#ref-footnote-1' title='回到文档' class='reversefootnote' >↩</a></div></div><script src="./public/highlight.min.js"></script>
<script src="./public/highlightjs-copy-button.min.js"></script>
<script src="./public/MarkdownPad2AutoCatalog.js"></script>
<script src="./public/index.js"></script></body>
</html>